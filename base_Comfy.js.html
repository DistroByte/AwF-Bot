<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: base/Comfy.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: base/Comfy.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file Jammy's core. Based off of ComfyBot
 */

const { Client, Collection, MessageEmbed } = require('discord.js');
const NodeCache = require("node-cache");
const factorioServers = require("../servers");
const FIFO = require("fifo")

const util = require('util'),
  path = require('path'),
  AmeClient = require("amethyste-api"),
  moment = require('moment');

class Comfy extends Client {
  constructor(options) {
    super(options)
    this.consts = require("../consts")
    this.config = require('../config');
    this.emotes = this.config.emojis;

    this.commands = new Collection();
    this.aliases = new Collection();

    this.logger = require('../helpers/logger');
    this.functions = require('../helpers/functions');
    this.wait = util.promisify(setTimeout);

    this.guildsData = require('./Guild');
    this.usersData = require('./User');
    this.membersData = require('./Member');
    this.logs = require('./Log');

    this.serverQueues = new Map();
    factorioServers.forEach((server) => {
      if (!server.discordid) return
      this.serverQueues.set(server.discordid, {
        server: server,
        messageQueue: FIFO(),
        sendingMessage: false
      })
    })
    setInterval(() => {
      this.serverQueues.forEach((server) => {
        if (server.sendingMessage === true) return
        server.sendingMessage = true
        let message = ""
        while (!server.messageQueue.isEmpty()) {
          let content = server.messageQueue.first()
          if (message.length + server.messageQueue.first().length > this.consts.discordMessageLengthLimit) break
          server.messageQueue.shift()
          message += `${server.messageQueue.first()}\n`
        }
        if (message.length) {
          this.channels.cache.get(server.server.discordid)?.send(message).then(() => server.sendingMessage = false)
        } else server.sendingMessage = false
      })
    }, 50)
    this.factorioServers = factorioServers

    this.states = {};

    this.knownGuilds = []

    this.databaseCache = {};
    this.databaseCache.users = new Collection();
    this.databaseCache.guilds = new Collection();
    this.databaseCache.members = new Collection();
    this.databaseCache.usersReminds = new Collection();
    this.databaseCache.mutedUsers = new Collection();
    this.databaseCache.factorioServers = new Collection();

    this.cache = {}
    this.cache.linkingCache = new NodeCache({stdTTL: 600})

    this.AmeAPI = new AmeClient(this.config.apiKeys.amethyste);
  }

  printDate(date, format) {
    return moment(new Date(date))
      .locale('UTC')
      .format('hh:mm a, DD-MM-YYYY');
  }

  loadCommand(commandPath, commandName) {
    try {
      const props = new (require(`.${commandPath}${path.sep}${commandName}`))(this);
      props.conf.location = commandPath;
      if (props.init) {
        props.init(this);
      }
      this.commands.set(props.help.name, props);
      props.help.aliases.forEach((alias) => {
        this.aliases.set(alias, props.help.name);
      });
      return false;
    } catch (e) {
      return `Unable to load command ${commandName}: ${e}`;
    }
  }

  async unloadCommand(commandPath, commandName) {
    let command;
    if (this.commands.has(commandName)) {
      command = this.commands.get(commandName);
    } else if (this.aliases.has(commandName)) {
      command = this.commands.get(this.aliases.get(commandName));
    }
    if (!command) {
      return `The command \`${commandName}\` doesn't seem to exist, nor is it an alias. Try again!`;
    }
    if (command.shutdown) {
      await command.shutdown(this);
    }
    delete require.cache[require.resolve(`.${commandPath}${path.sep}${commandName}.js`)];
    return false;
  }

  async findOrCreateGuild({ id: guildID }, isLean) {
    if (this.databaseCache.guilds.get(guildID)) {
      return isLean ? this.databaseCache.guilds.get(guildID).toJSON() : this.databaseCache.guilds.get(guildID);
    } else {
      let guildData = (isLean ? await this.guildsData.findOne({ id: guildID }).populate('members').lean() : await this.guildsData.findOne({ id: guildID }).populate('members'));
      if (guildData) {
        if (!isLean) this.databaseCache.guilds.set(guildID, guildData);
        return guildData;
      } else {
        guildData = new this.guildsData({ id: guildID });
        await guildData.save();
        this.databaseCache.guilds.set(guildID, guildData);
        return isLean ? guildData.toJSON() : guildData;
      }
    }
  }

  async findOrCreateMember({ id: memberID, guildID }, isLean) {
    if (this.databaseCache.members.get(`${memberID}${guildID}`)) {
      return isLean ? this.databaseCache.members.get(`${memberID}${guildID}`).toJSON() : this.databaseCache.members.get(`${memberID}${guildID}`);
    } else {
      let memberData = (isLean ? await this.membersData.findOne({ guildID, id: memberID }).lean() : await this.membersData.findOne({ guildID, id: memberID }));
      if (memberData) {
        if (!isLean) this.databaseCache.members.set(`${memberID}${guildID}`, memberData);
        return memberData;
      } else {
        memberData = new this.membersData({ id: memberID, guildID: guildID });
        await memberData.save();
        const guild = await this.findOrCreateGuild({ id: guildID });
        if (guild) {
          guild.members.push(memberData._id);
          await guild.save();
        }
        this.databaseCache.members.set(`${memberID}${guildID}`, memberData);
        return isLean ? memberData.toJSON() : memberData;
      }
    }
  }

  async findOrCreateUser({ id: userID }, isLean) {
    if (this.databaseCache.users.get(userID)) {
      return isLean ? this.databaseCache.users.get(userID).toJSON() : this.databaseCache.users.get(userID);
    } else {
      let userData = (isLean ? await this.usersData.findOne({ id: userID }).lean() : await this.usersData.findOne({ id: userID }));
      if (userData) {
        if (!isLean) this.databaseCache.users.set(userID, userData);
        return userData;
      } else {
        userData = new this.usersData({ id: userID });
        await userData.save();
        this.databaseCache.users.set(userID, userData);
        return isLean ? userData.toJSON() : userData;
      }
    }
  }
  async findUserFactorioName(factorioname, isLean) {
    let userData = (isLean ? await this.usersData.findOne({ factorioName: factorioname }).lean() : await this.usersData.findOne({ factorioName: factorioname }));
    if (!isLean &amp;&amp; userData?.id) this.databaseCache.users.set(userData?.id, userData);
    return userData;
  }

  convertTime(time, type, noPrefix, locale) {
    if (!type) time = 'to';
    const m = moment(time).locale('UTC');
    return (type === 'to' ? m.toNow(noPrefix) : m.fromNow(noPrefix));
  }

  async resolveUser(search) {
    let user = null;
    if (!search || typeof search !== "string") return;
    // Try ID search
    if (search.match(/^&lt;@!?(\d+)>$/)) {
      const id = search.match(/^&lt;@!?(\d+)>$/)[1];
      user = this.users.fetch(id).catch(() => { });
      if (user) return user;
    }
    // Try username search
    if (search.match(/^!?(\w+)#(\d+)$/)) {
      const username = search.match(/^!?(\w+)#(\d+)$/)[0];
      const discriminator = search.match(/^!?(\w+)#(\d+)$/)[1];
      user = this.users.cache.find((u) => u.username === username &amp;&amp; u.discriminator === discriminator);
      if (user) return user;
    }
    if (search.match(/^!?(\w+)$/)) {
      user = this.users.cache.find((u) => u.username.toLowerCase() === search.toLowerCase())
      if (user) return user;
    }
    user = await this.users.fetch(search).catch(() => { });
    return user;
  }

  async resolveMember(search, guild) {
    let member = null;
    if (!search || typeof search !== 'string') return;
    // Try ID search
    if (search.match(/^&lt;@!?(\d+)>$/)) {
      const id = search.match(/^&lt;@!?(\d+)>$/)[1];
      member = await guild.members.fetch(id).catch(() => { });
      if (member) return member;
    }
    // Try username search
    if (search.match(/^!?(\w+)/)) {
      guild = await guild.fetch();
      member = guild.members.cache.find((m) => (m.user.tag.toLowerCase() === search || m.user.username.toLowerCase() === search));
      if (member) return member;
    }
    member = await guild.members.fetch(search).catch(() => { });
    return member;
  }

  async resolveRole(search, guild) {
    let role = null;
    if (!search || typeof search !== 'string') return;
    // Try ID search
    if (search.match(/^&lt;@&amp;!?(\d+)>$/)) {
      const id = search.match(/^&lt;@&amp;!?(\d+)>$/)[1];
      role = guild.roles.cache.get(id);
      if (role) return role;
    }
    // Try name search
    role = guild.roles.cache.find((r) => search === r.name);
    if (role) return role;
    role = guild.roles.cache.get(search);
    return role;
  }
}

module.exports = Comfy;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="-_UPSHandler.html">_UPSHandler</a></li><li><a href="rconInterface.html">rconInterface</a></li><li><a href="ServerFifoManager.html">ServerFifoManager</a></li></ul><h3>Global</h3><ul><li><a href="global.html#bubbleSort">bubbleSort</a></li><li><a href="global.html#getServerFromChannelInput">getServerFromChannelInput</a></li><li><a href="global.html#runShellCommand">runShellCommand</a></li><li><a href="global.html#sortModifiedDate">sortModifiedDate</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.4</a> on Sat May 01 2021 16:32:56 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
